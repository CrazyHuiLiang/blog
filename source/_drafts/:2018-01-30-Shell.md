# Shell
Shell是一个命令行解释器，它为用户提供了一个向Linux内核发送请求以便运行程序的界面系统级程序，用户可以用Shell来启动、挂起、停止甚至编写一些程序。

Shell还是一个功能相当强大的编程语言，易编写，易调试，灵活性较强。Shell是解释执行的脚本语言，在Shell中可以直接调用Linux系统命令。

Bourne Shell： 从1979起Unix就开始使用，其主文件名为sh。
C Shell： C Shell主要用于BSD版的Unix系统中使用，其语法和C语言相类似而得名。

Shell的两种主要语法类型有Bourne和C，这两种语法彼此不兼容。Bourne家族主要包括sh、ksh、Bash、psh、zsh；C家族主要包括：csh、tcsh。

Bash：与sh兼容，现在使用的Linux就是使用Bash作为用户的基本Shell。


查询linux支持的shell
/etc/shells


echo输出命令
echo [选项] [输出内容]
-e 支持反斜线控制的字符转换

echo -e '\e[1;31m abcd \e[0m'
输出颜色
30m=黑色
31m=红色
32m=绿色
33m=黄色
34m=蓝色
35m=洋红
36m=青色
37m=白色

##脚本执行
赋予执行权限，直接运行
chmod 755 hello.sh
./hello.sh

通过Bash调用执行脚本
Bash hello.sh

dos2unix 可以转换windows中编写的脚本到linux。


##历史命令
history [选项] [历史命令保存文件]
-c: 清空历史命令
-w: 把缓存中的历史命令写入历史命令保存文件 ~/.bash_history

历史命令默认会保存1000条，可以在环境变量配置文件/etc/profile中进行修改


历史命令的调用
使用上、下箭头调用以前的历史命令
使用 "!n" 重复执行第n条历史命令
使用 "!!" 重复执行上一条命令
使用 "!字串" 重复执行最后一条以该字串开头的命令

##命令与文件补全
在Bash中，命令与文件补全是非常方便与常用的功能，我们只要在输入命令或文件时，按“Tab”键就会自动进行补全。


##命令别名

设置命名别名
alias 别名='原命令'

查询命令别名
alias

命令执行时顺序
1、执行用绝对路径或相对路径执行的命令
2、执行别名
3、执行Bash的内部命令(如：cd)。
4、执行按照$PATH环境变量定义的目录查找顺序找到第一个命令。

让别名永久生效需要将别名定义写在相应地配置文件。
vi ~/.bashrc

删除别名：
unalias 别名

##Bash常用快捷键
ctrl+A 把光标移动到命令开头。如果我们输入的命令过长，想要把光标移动到命令行开头时使用。
ctrl+E 把光标移动到命令行结尾
ctrl+C 强制终止当前的命令
ctrl+L 清屏，相当于clear命令

ctrl+U 删除或剪切光标之前的命令。我输入了一行很长的命令，不用使用退格键一个一个字符的删除，使用这个快捷键会更加方便
ctrl+K 删除或剪切光标之后的内容
ctrl+P 粘贴ctrl+U或ctrl+K剪切的内容

ctrl+R 在历史命令中搜索，按下ctrl+R之后，就会出现搜索界面，只要输入搜索内容，就会从历史命令中搜索
ctrl+D 退出当前终端
ctrl+Z 暂停，并放入后台。

ctrl+S 暂停屏幕输出
ctrl+Q 恢复屏幕输出

##输入输出重定向

###标准输入输出
设备        设备文件名      文件描述符      类型
键盘     /dev/stdin         0               标准输入
显示器   /dev/sdtout        1               标准输出
显示器   /dev/sdterr        2               标准错误输出

###输出重定向
标准输出重定向
命令 > 文件： 以覆盖的方式，把命令的正确输出输出到指定的文件或设备当中
命令>> 文件： 以追加的方式，把命令的正确输出输出到指定的文件或设备当中
标准错误输出重定向
错误命令 2> 文件： 以覆盖的方式，把命令的错误输出输出到指定的文件或设备当中
错误命令 2>>文件： 以追加的方式，把命令的错误输出输出到指定的文件或设备当中

正确输出和错误输出同时保存
命令 >文件 2>&1     :以覆盖的方式，把正确输出和错误输出都保存到同一个文件当中。
命令>>文件 2>&1     :以追加的方式，把正确输出和错误输出都保存到同一个文件当中。
命令 &>文件         :以覆盖的方式，把正确输出和错误输出都保存到同一个文件当中。
命令 &>>文件        :以追加的方式，把正确输出和错误输出都保存到同一个文件当中。
命令>>文件1 2>>文件2:把正确的输出追加到文件1中，把错误的输出追加到文件2中。

###输入重定向
命令 < 文件 ： 把文件作为命令的输入
命令 << xx   ： 输入中出现xx后结束输入
如：
wc [选项] [文件名]
-c 统计字节数
-w 统计单词数
-l 统计行数
-m 只统计字符数

wc < abc

##多命令顺序执行

多命令执行符        格式                 作用
;                   命令1;命令2         多个命令顺序执行，命令之间没有任何逻辑联系
&&                  命令1&&命令2        逻辑与，当命令1正确执行，则命令2才会执行
||                  命令1||命令2        逻辑或，当命令1执行不正确，则命令2才会执行

dd if=输入文件 of=输出文件 bs=字节数 count=个数
选项：
if=输入文件         指定源文件或源设备
of=输出文件         指定目标文件或目标设备
bs=字节数           指定一次输入／输出多少字节，即把这些字节看做一个数据块
count=个数          指定输入／输出多少个数据块
例子：
data; dd if=/dev/zero of=/root/testfile bs=1k count=100000; date


##管道符
命令1  | 命令2
命令1的正确输出作为命令2的操作对象

例子：
ll -a /etc/ | more
netstat -an | grep "ESTABLISHED"


在文件中搜索关键字
grep [选项] "搜索内容" 文件名
选项：
-i      忽略大小写
-n      输出行号
-v      反向查找
--color=auto    搜索出的关键字用颜色显示

##通配符
?   匹配一个任意字符
*   匹配0个或任意多个任意字符，也就是可以匹配任何内容
[]  匹配中括号中任意一个字符。例如：[abc]代表一定匹配一个字符，或者是a，或者是b，或者是c。
[-] 匹配中括号中任意一个字符，-代表一个范围。例如[a-z],代表匹配一个小些字母。
[^] 逻辑非，表示匹配不是中括号内的一个字符。例如：[^0-9]代表匹配一个不是数字的字符。

##特殊符号
''  单引号。在单引号中所有的特殊符号，如"$"和"`"(反引号)都没有特殊含义。
""  双引号。在双引号中特殊符号都没有特殊含义，但是"$", "`"和"\"是例外，拥有“调用变量的值”、“引用命令”和”转义符“的特殊含义
``  反引号。反引号括起来的内容是系统命令，在Bash中会先执行它。和$()作用一样，不过推荐使用$()，因为反引号非常容易看错。
$() 和反引号作用一样，用来引用系统命令。
\#  在Shell脚本中，#开头的行代表注射。 
$   用于调用变量的值，如需要调用变量name的值时，需要用$name的方式得到变量的值。
\   转义符，跟在\之后的特殊符号将失去特殊含义，变成普通字符。如\$将输出“$”，而不当做是变量引用。



##变量

变量设置规则
1. 命名不能以数字开头
2. 变量默认类型是字符串型，如果要进行数值运算，则必须指定变量类型为数值型
3. 等号左右两侧不能有空格
4. 变量如果有空格，需要使用括号包括
5. 变量的值中可以使用'\'转义符
6. 如果需要增加变量的值，那么可以进行变量值的叠加。不过变量需要用双引号包含"$变量名"或用${变量名}包含。
7. 如果是把命令的结果作为变量值赋予变量，则需要使用反引号或$()包含命令。
8. 环境变量名建议大些，便于区分。

变量分类
1. 用户自定义变量
2. 环境变量：主要保存的是和系统操作环境相关数据
3. 位置参数变量：主要是用来向脚本当中传递参数或数据的，变量名不能自定义，变量作用是固定的。
4. 预定义变量：是Bash中已经定义好的变量，变量名不能自定义，变量作用也是固定好的。

###用户自定义变量
定义变量name=123
name=123
变量叠加
name="$name"456
name=${name}789

变量调用
echo $name


查看系统所有的变量
set

变量删除
unset name

###环境变量
用户自定义变量只在当前的Sehll中生效，而环境变量会在当前Sehll和这个Shell的所有子Shell当中生效。如果把环境变量写入相应的配置文件，那么这个环境变量就会在所有的Shell中生效。

设置环境变量
申明变量
export 变量名=变量值

查询变量
env

删除变量
unset 变量名



#cut字段提取命令
cut [选项] 文件名
-f 列号：  提取第几列
-d 分隔符： 按照指定分隔符分隔列


####系统常见环境变量
PATH: 系统查找命令的路径
PS1: 定义系统提示符的变量

###位置参数变量
用处：将命令行参数传递进程序中

位置参数变量		作用
$n				n为数字，$0代表命令本身，$1-$9代表第一个到第九个参数，十以上的参数需要用大括号包含，如${10}.
$*				这个变量代表命令行中所有的参数，$*把所有的参数看成一个整体
$@				这个变量也代表命令行中所有的参数，不过$@把每个参数区分对待
$#				这个变量代表命令行中所有参数的个数


###预定义变量

预定义变量			作用
$?				最后一次执行的命令的返回状态。如果这个变量的值为0，证明上一个命令正确执行；如果这个变量的值为非0（具体是哪个数，由命令自己来决定），则证明上一个命令执行不正确了。
$$				当前进程的进程号(PID)
$!				后台运行的最后一个进程的进程号(PID)

###接收键盘输入
read [选项][变量名]
-p	'提示信息'  : 在等待read输入时，输出提示信息
-t 秒数			:read命令会一直等待用户输入，使用此选项可以指定等待时间。
-n 字符数		:read命令只接受指定的字符数，就会执行
-s				:隐藏输入的数据，适用于机密信息的输入



#数值运算与运算符

1、declare声明变量类型
declare [+/-][选项] 变量名
选项：
-:	给变量设定类型属性
+:	取消变量的类型属性
-i:	将变量声明为整数型（integer）
-x:	将变量声明为环境变量
-p:	显示指定变量的被声明的类型


2、expr或let数值运算工具
aa=11
bb=22
给变量aa和变量bb赋值
dd=$(expr $aa + $bb)
dd的值是aa和bb的和。注意 "+"号左右两侧必须有空格

3、$((运算式))或$[运算式]
aa=11
bb=22
ee=$(($aa+$bb))




#环境变量配置文件
1、source命令
source 配置文件
或
. 配置文件

2、环境变量配置文件中主要是定义对系统的操作环境生效的系统默认环境变量，比如PATH、HISTSIZE、PS1、HOSTNAME等默认环境变量。

#环境变量配置文件
1、source命令
source 配置文件
或
. 配置文件


配置文件
/etc/profile
/etc/profiles.d/*.sh
~/.bash_profile
~/.bashrc
/etc/bashrc

其他配置文件
1、注销时生效的环境变量配置文件
~/.bash_logout
2、历史命令
~/.bash_history
3、Shell登录信息
本地终端登录信息：/etc/issue
远程终端登录信息：/etc/issue.net
	转义符在/etc/issue.net文件中不能使用
	是否显示此登录信息，由ssh的配置文件/etc/ssh/sshd_config决定，加入“Banner /etc/issue.net“行才能显示（记得重启SSH服务 service sshd restart）
登录后欢迎信息：/etc/motd
	不管是本地登录，还是远程登录，都可以显示欢迎信息。






	



#printf
printf ‘输出类型输出格式’ 输出内容
%ns:  输出字符串。n是数字指代输出几个字符
%ni:  输出整数。n是数字指代输入几个数字
%m.nf:输出浮点数。m和n是数字，指代输出的整数位数和小数位数。如%8.2f代表共输出8位数，其中2位是小数，6位是整数。

输出格式：
\a: 输出警告声音
\b: 输出退格键，也就是Backspace健
\f: 清楚屏幕
\n: 换行
\r: 回车，也就是Enter键
\t: 水平输出退格键，也就是Tab键
\v: 垂直输出退格键，也就是Tab键


在awk命令的输出中支持print和printf命令
print: print会在每个输出之后自动加入一个换行符（Linux默认没有print命令）
printf: printf是标准格式输出命令，并不会自动加入换行符，如果需要换行，需要手工加入换行符
#awk
awk ‘条件1{动作1} 条件2{动作2}...‘ 文件名
条件（Pattern）：
一般使用关系表达式作为条件
x>10  判断变量x是否大于10
x<=10 小于等于
动作（Action）：
格式化输出
流程控制语句

BEGIN
awk 'BEGIN{print "This is a transcript"}{printf $2 "\t" $6 "\n"} student.txt
END
awk 'BEGIN{FS=":"}{print $1"\t"$3}END{print "hello"}' /etc/passwd

FS内置变量
定义分隔符
awk 'BEGIN{FS=":"}{print $1"\t"$3}' /etc/passwd | grep '^[^#^_]'

#sed 
是一种几乎包括在所有UNIX平台的轻量级流编辑器。sed主要是用来将数据进行选取、替换、删除、新增的命令。

sed [选项] '[动作]' 文件名
-n: 一般sed命令会把所有数据都输出到屏幕，如果加入此选项，则只会把经过sed命令处理的行输出到屏幕
-e: 允许对输入数据应用多条sed命令编辑
-i: 用sed的修改结果直接修改读取数据的文件，而不是由屏幕输出

动作：
a\: 追加，在当前行后添加一行或多行。添加多行时，除最后一行外，每行末尾需要用“\“代表数据未完结。
c\: 行替换，用c后面的字符串替换原数据行，替换多行时，除最后一行外，每行末尾需要“\“代表数据未完结。
i\: 插入，在当期行前插入一行或多行。插入多行时，除最后一行外，每行末尾需要用“\”代表数据未完结
d: 删除，删除指定的行
p: 打印，输出指定的行
s: 字串替换，用一个字符串替换另外一个字符串。格式为“行范围s/旧字串/新字串/g"(和vim中替换格式类似。


# 排序命令 sort
sort [选项] 文件名
-f: 忽略大小写
-n: 以数值型进行排序，默认使用字符串型排序
-r: 反向排序
-t: 指定分隔符，默认是分隔符是制表符
-k n[,m]: 按照指定的字段范围排序。从第n字段开始，m字段结束（默认到行尾）

















#条件判断

1、按照文件类型进行判断

测试选项  作用
-b 文件判断该文件是否存在，并且是否为块设备文件（是块设备文件为真）
-c 文件 判断文件是否存在，并且是否为字符设备文件（是字符设备文件为真）
-d 文件 判断该文件是否存在，并且是否为目录文件（是目录为真）
-e 文件 判断该文件是否存在（存在为真）
-f 文件 判断该文件是否存在，并且是否为普通文件（是普通文件为真）
-L 文件 判断该文件是否存在，并且是否为符号链接文件（是符号链接文件为真）
-p 文件 判断该文件是否存在，并且是否为管道文件（是管道文件为真）
-s 文件 判断该文件是否存在，并且是否为非空（非空为真）
-S 文件 判断该文件是否存在，并且是否为套接字文件（是套接字文件为真)


两种判断格式
1. test -e /root/install.log
2. [ -e /root/install.log ]  注意：-e前要有空格，路径后也要有空格
   [ -e /etc/passwd ] && echo "yes" || echo "no"

2、 按照文件权限进行判断
测试选项  作用
-r 文件  判断该文件是否存在，并且是否该文件拥有读权限（有读权限为真）
-w 文件  判断该文件是否存在，并且是否该文件拥有写权限（有写权限为真）
-x 文件  判断该文件是否存在，并且是否该文件拥有执行权限（有执行权限为真）
-u 文件  判断该文件是否存在，并且是否该文件拥有SUID权限（有SUID权限为真）
-g 文件  判断该文件是否存在，并且是否该文件拥有SGID权限（有SGID权限为真）
-k 文件  判断该文件是否存在，并且是否该文件拥有SBit权限（有SBit权限为真）


3、两个文件之间进行比较
测试选项  作用
文件1 -nt 文件2  判断文件1的修改时间是否比文件2的新（如果新则为真）
文件1 -ot 文件2  判断文件1的修改时间是否比文件2的旧（如果旧则为真）
文件1 -ef 文件2  判断文件1是否和文件2的inode号一致，可以理解为两个文件是否为同一个文件。这个判断用于判断硬连接是很好的方法

4、两个整数之间比较
测试选项  作用
整数1 -eq 整数2  判断整数1是否和整数2相等（相等为真）
整数1 -ne 整数2  判断整数1是否和整数2不相等（不相等为真）
整数1 -gt 整数2  判断整数1是否大于整数2（大于为真）
整数1 -lt 整数2  判断整数1是否小于整数2（小于为真）
整数1 -ge 整数2  判断整数1是否大于等于整数2（大于等于为真）
整数1 -le 整数2  判断整数1是否小于等于整数2（小于等于为真）

5、字符串的判断
测试选项  作用
-z 字符串  判断字符串是否为空（为空返回真）
-n 字符串  判断字符串是否非空（非空返回真）
字串1 == 字串2  判断字符串1是否和字符串2相等（相等返回真）
字串1 != 字串2  判断字符串1是否和字符串2不相等（不相等返回真）

6、多重条件判断
测试选项  作用
判断1 -a 判断2  逻辑与，判断1和判断2都成立，最终的结果才为真
判断1 -o 判断2  逻辑或，判断1和判断2有一个成立，最终的结果就为真
! 判断 逻辑非，使原始的判断式取反


#if 语句

1、 单分支if条件语句

if [条件判断式 ];then
  程序
fi
或者
if [ 条件判断式 ]
  then
    程序
fi

单分支条件语句需要注意几个点
if语句使用fi结尾，和一般语言使用打括号结尾不同
[ 条件判断式 ]就是使用test命令判断，所以中括号和条件判断式之间必须有空格
then后面跟符合条件之后执行的程序，可以放在[]之后，用“;“分割。也可以换行写入，就不需要";"了


2、双分支if条件语句
if [ 条件判断式 ]
  then
    条件成立时，执行的程序
  else
    条件不成立时，执行的另一个程序
fi

3、 多分支if条件语句
if [ 条件判断式1 ]
  then
    当条件判断式1成立时，执行程序1
elif [ 条件判断2 ]
  then
    当条件判断式2成立时，执行程序2
else
  当所有条件都不成立时，最后执行此程序
fi

#case语句
case $变量名 in
  "值1")
    如果变量的值等于值1，执行程序1
    ;;
  "值2")
    如果变量的值等于值2，则执行程序2
    ;;
  *)
    如果变量的值都不是以上的值，则执行此程序
    ;;
esac

# for循环
语法一：
for 变量 in 值1值2值3
  do
    程序
done

语法二：
for((初始值;循环控制条件;变量变化))
  do
    程序
  done

# while循环
while [ 条件判断式 ]
  do
    程序
  done
# until循环
until循环和while循环相反，until循环是只要条件判断式不成立则进行循环，并执行循环程序，一旦循环条件成立，则终止循环
until [ 条件判断式 ]
  do
    程序
  done









