# Ajax跨域的解决方案


摘要

Ajax（Asynchronous JavaScript and XML）中文名称：异步Javascript与XML。由于其可以在不刷新网站页面的的情况下获取新的数据，且还支持同步和异步两种方式（使用方便），而被广泛应用于网站前端。
关键词：网站开发，Javascript，Ajax，跨域
正文

在ajax出现之前，网站需要和后台交互惯用的方法是通过表单提交，在html文件中使用`<form>`标签，通常一个请求就是一个表单提交。表单提交有一个特点就是，当用户点击‘submit’按钮后（表单提交的请求发出）浏览器就会刷新页面，当前网页不会接收请求的具体结果，然后在新页面里告诉你操作是成功了还是失败了。如果不幸由于网络太慢或者其他原因，就会得到一个404页面。这就是Web的运作原理：一次HTTP请求对应一个页面。比如我们经常会遇到的场景，在登录页面，我们输入帐号和密码，点击登录，如果登录成功，页面就会跳转到网站首页或者个人信息页面，如果输入的帐号或者密码是错误的，通常页面会再次跳转到登录页面提示我们帐号错误或者密码错误，需要重新输入，重新登录。

而当我们有了ajax之后，我们就可以使用javascript发送请求，再有javascript更新页面，这样一来，用户就感觉自己仍然停留在当前页面，但是数据却可以不断地更新。比较典型的例子就是谷歌地图，打开谷歌地图后，我们可以用鼠标拖动地图，然后新的区域的地图在不需要页面刷新的情况下就可以展现出来。

通过以上对比我们可以看出有了ajax之后我们的网页的体验，和速度确实增幅不少。用JavaScript写一个完整的AJAX代码并不复杂，在现代浏览器上写AJAX主要依靠XMLHttpRequest对象。

下面显示一个完整的ajax的代码，每行代码后面标注了其含义：
```实例
var request = new XMLHttpRequest(); // 新建XMLHttpRequest对象
request.onreadystatechange = function () { // 注册请求状态发生变化的回调，状态发生变化时，函数会被调用
if (request.readyState === 4) { // readyState为4代表请求成功完成
//在这里可以执行请求完成的操作
} else {
// HTTP请求还在继续...
}
}
// 发送请求:
request.open('GET', '/api');
request.send();
```

对于低版本的IE，需要换一个ActiveXObject对象，其使用方法和XMLHttpRequest一般无二，在这里就不再多举例子。

ajax除了使用方便等优点外，还有一些限制，浏览器出于安全考虑有着同源策略，同源策略限制了一个源（origin）中加载文本或脚本与来自其它源（origin）中资源的交互方式。如果两个页面拥有相同的协议（protocol），端口（如果指定），和主机，那么这两个页面就属于同一个源（origin）。只有同源的请求才可以正常的接收，不同源的请求无法接收到结果。

有了这些限制是不是就绝对无法访问其他域的数据了呢？答案是否定的，方法还是有的。大约分为一下几种：

1、通过Flash插件发送HTTP请求，这种方式可以绕过浏览器的安全限制，但必须安装Flash，并且跟Flash交互。不过Flash用起来麻烦，而且现在用得也越来越少了。

2、图像ping，我们知道，一个网页可以从任何网页中加载图像，没有跨域的限制，因此我们就可以动态的创建图像，使用它们的onload和onerrer事件处理程序来确定是否接收到了响应。这种方式多用于与服务器进行简单、单向的跨域通信的一种方式。请求的数据是通过查询字符串形式发送的，而响应可以是任意的内容，通过图像ping，浏览器得不到任何具体的数据，仅可通过监听load和error事件，能知道请求的返回。例如，我想为我的网站的某个功能添加埋点，记录该功能被使用的次数，我们就可以像下方例子这样做：

```实例
var img = new Image();
img.onload = img.onerror = function(){
console.log('请求结束');
};
img.src = 'http:127.0.0.2:8888/maidian?function=login';
```

这里创建了一个image的实例，然后注册onload和onerror的监听，这样无论结果如何，只要请求完成，就能得到通知。当我们为img指定src开始，一个带着function＝login参数的请求就被发了出去。

这种请求方式有两个主要的缺点，一是只能发送GET请求，二是无法访问相应文本。因此只能用于浏览器与服务器间的单向通信。再多分析一下，图像ping实际上是利用了<img>标签可以执行跨域请求的功能，换句话说，是Dom有跨域请求的功能，想明白这一点估计也就能想到，是不是其他的一些需要引用资源的标签是否也可以实现同样的功能，答案是确定的。类似于`<img>`还有`<link>`, `<video>`,`<audio>`,`<object>`,`<embed>`,`<applet>`,`<iframe>`,`<script>`等，除去`<script>`标签可以具有更巧妙的jsonp用法外，其他的也如图像ping类似，就不再多举例子了。

3、还有一种目前较为常用方式称为JSONP，它有个限制，只能用GET请求，并且要求返回JavaScript。这种方式跨域实际上是利用了浏览器允许跨域引用JavaScript资源。JSONP通常以函数调用的形式返回，例如，返回JavaScript内容如下：foo('data');这样一来，我们如果在页面中先准备好foo()函数，然后给页面动态加一个`<script>`节点，相当于动态读取外域的JavaScript资源，最后就等着接收回调了。以一个我们常见的情景为例，比如我们需要获取用户的基本信息，假如我们需要获取用户的用户名，性别和年龄三个字段。
接口为http:127.0.0.2:8888/userInfo, 我们需要的数据为{'name':'Ajax','sex':'female','age':'18'},

因此我们需要首先在页面中准备好回调函数：

```实例
function showPersion(data) {
console.log('My name is ' + data.name + ',i am' + data.age + 'years old');
}
```

然后创建script标签，

```实例
var js = document.createElement('script')；
```
并将我们需要请求的url后面跟上请求参数callback等于我们预先准备好的回调函数showPersion。

```实例
js.src = 'http:127.0.0.2:8888/userInfo?callback=showPersion';
```


并将script标签插入文档中。
```实例
head = document.getElementsByTagName('head')[0];
head.appendChild(js);
```

script标签插入文档后，浏览器就会如同加载js代码一样，以get请求的方式去获取src所链接的资源，当后台收到请求后，可以得到请求参数callback的值showPersion，后台需要将数据包装到showPersion(“”)中进行返回。如showPersion(“{'name':'Ajax','sex':'female','age':'18'}“）
当浏览器收到数据后会理所应当的认为返回数据是一段js代码，运行这段代码，恰好就是调用了我们前面预先准备好的函数showPersion，并将数据{'name':'Ajax','sex':'female','age':'18'}当成参数成功的传入函数体内。
这样就完成了跨域加载数据，也是因为jsonp是利用了script标签可以跨域加载资源的这一特点，让请求通过加载脚本的方式进行的，而加载脚本只有get请求一种方式，所以jsonp这种方式也只能用于get请求。

4、如果浏览器支持HTML5，那么就有新的跨域策略CORS了,CORS全称Cross-Origin Resource Sharing，是HTML5规范定义的在必须访问跨源资源时，浏览器与服务器应该如何沟通。CORS背后的基本思想，就是使用自定义的HTTP头部让浏览器与服务器进行沟通，从而决定请求或响应是应该成功，还是应该失败。

比如一个简单的使用GET或POST发送的请求，它没有自定义的头部，而主体内容是text/plain。在发送该请求时，需要给它附加一个额外的Origin头部，其中包含请求页面的源信息（协议、域名和端口），以便服务器根据这个头部信息来决定是否给予响应。下面是Origin头部的一个示例：

Origin: http://www.nczonline.net
如果服务器认为这个请求可以接受，就在Access-Control-Allow-Origin头部中回发相同的源信息（如果是公共资源，可以回发"*"）。例如：

Access-Control-Allow-Origin: http://www.nczonline.net

如果没有这个头部，或者有这个头部但源信息不匹配，浏览器就会驳回请求。正常情况下，浏览器会处理请求。请求和响应都不包含cookie信息。

5、在跨域请求的前提下，上面谈到的各种方法都有无法携带cookie的问题，那么，如果既要跨域又想携带cookie，怎么办？方法也有，使用反向代理！用nginx／apache反向代理实现跨域，是最简单的跨域方式。只需要修改nginx／apache的配置即可解决跨域问题，支持所有浏览器，支持cookie，不需要修改任何代码，并且不会影响服务器性能。我们只需要配置nginx／apache，在一个服务器上配置多个前缀来转发http/https请求到多个真实的服务器即可。这样，这个服务器上所有url都是相同的域名、协议和端口。因此，对于浏览器来说，这些url都是同源的，没有跨域限制。

我们拿使用nginx设置反向代理来举一个例子：

假设我们我们当前的站点是www.a.com,我们需要访问的资源是: http://www.b.com/course/api/list

```实例
server {
listen 80;
charset utf-8;
server_name www.a.com;
server_name_in_redirect off;
root /a;
location /course/api/list {
proxy_pass http://www.b.com/course/api/list;
proxy_redirect off;
proxy_set_header Host $host;
proxy_set_header X-Real-IP $remote_addr;
proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
}
}
```
上面这段nginx配置，前6行是一些为了开启www.a.com站点的服务所写，后面的location所包的一段文字就是开启反向代理的配置，在location后面跟的是我们请求的前缀的监测的规则，在这里我们就直接写了/course/api/list，这些配置设置完成后，假如我们想要在www.a.com访问接口http://www.b.com/course/api/list 只需要在 www.a.com 中访问http://www.a.com/course/api/list 即可，当请求发出后，我们的本地服务器（nginx）发现这个接口于我们上面的反向代理的匹配规则能够匹配，就会把我们的请求自动转发到配置中的proxy_pass上，也就是http://www.b.com/course/api/list ，并把请求的response取回来，跨域完成。因为我们的www.a.com发出的请求的域名和协议和端口都和当前站一样，浏览器自然不会认为我们我们跨域了，自然就不会有各种跨域的限制，不管是请求方式，还是cookie自然也就可以正常使用。






>参考文献：
>浏览器的同源策略 https://developer.mozilla.org/zh-CN/docs/Web/Security/Same-origin_policy
>HAYAGEEK http://hayageek.com/cross-domain-ajax-request-jquery
>w3 https://www.w3.org/TR/cors/
>廖雪峰http://www.liaoxuefeng.com/wiki/001434446689867b27157e896e74d51a89c25cc8b43bdb3000/001434499861493e7c35be5e0864769a2c06afb4754acc6000
>http://blog.jobbole.com/90975/




